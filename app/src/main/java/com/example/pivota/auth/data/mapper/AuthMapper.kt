package com.example.pivota.auth.data.mapper

import com.example.pivota.auth.data.remote.dto.AccountDto
import com.example.pivota.auth.data.remote.dto.OrganizationDto
import com.example.pivota.auth.data.remote.dto.UserDto
import com.example.pivota.auth.domain.model.AccountType
import com.example.pivota.auth.domain.model.SubscriptionPlan
import com.example.pivota.auth.domain.model.User
import com.example.pivota.auth.domain.model.UserRole
import com.example.pivota.core.database.entity.UserEntity

/**
 * --- REMOTE MAPPING (For Ktor/Backend) ---
 */

fun UserDto.toDomain(): User {
    val accountType = if (this.account.type == "ORGANIZATION" && this.organization != null) {
        AccountType.Organization(
            orgUuid = this.organization.uuid,
            orgName = this.organization.name,
            verificationStatus = this.organization.verificationStatus
        )
    } else {
        AccountType.Individual
    }

    return User(
        uuid = this.uuid,
        accountUuid = this.account.uuid,
        firstName = this.firstName ?: "",
        lastName = this.lastName ?: "",
        email = this.email,
        personalPhone = this.phone ?: "",
        role = try {
            UserRole.valueOf(this.roleName)
        } catch (e: Exception) {
            UserRole.GeneralUser
        },
        accountType = accountType,
        isVerified = this.status == "ACTIVE",
        isOnboardingComplete = this.status == "ACTIVE",
        createdAt = System.currentTimeMillis()
    )
}

fun User.toDto(): UserDto {
    val org = this.accountType as? AccountType.Organization
    return UserDto(
        uuid = this.uuid,
        userCode = "", // Generated by backend
        email = this.email,
        firstName = this.firstName,
        lastName = this.lastName,
        phone = this.personalPhone,
        roleName = this.role.name,
        status = if (this.isOnboardingComplete) "ACTIVE" else "INACTIVE",
        account = AccountDto(
            uuid = this.accountUuid,
            type = if (org != null) "ORGANIZATION" else "INDIVIDUAL",
            accountCode = ""
        ),
        organization = org?.let {
            OrganizationDto(
                uuid = it.orgUuid,
                name = it.orgName,
                orgCode = "",
                verificationStatus = it.verificationStatus
            )
        }
    )
}

/**
 * --- EXISTING: LOCAL MAPPING (For Room) ---
 */

fun UserEntity.toDomain(): User {
    val accountType = if (this.isOrganization) {
        AccountType.Organization(
            orgUuid = this.orgUuid ?: "",
            orgName = this.orgName ?: "",
            verificationStatus = this.verificationStatus ?: "PENDING"
        )
    } else {
        AccountType.Individual
    }

    return User(
        uuid = this.uuid,
        accountUuid = this.accountUuid,
        firstName = this.firstName ?: "",
        lastName = this.lastName ?: "",
        email = this.email,
        personalPhone = this.personalPhone ?: "",
        role = try {
            UserRole.valueOf(this.roleName)
        } catch (e: Exception) {
            UserRole.GeneralUser
        },
        accountType = accountType,
        isVerified = this.isVerified,
        selectedPlan = this.selectedPlan?.let {
            try { SubscriptionPlan.valueOf(it.uppercase()) }
            catch (e: Exception) { SubscriptionPlan.FREE_FOREVER }
        },
        isOnboardingComplete = this.isOnboardingComplete,
        createdAt = System.currentTimeMillis()
    )
}

fun User.toEntity(): UserEntity {
    val org = this.accountType as? AccountType.Organization
    return UserEntity(
        uuid = this.uuid,
        accountUuid = this.accountUuid,
        email = this.email,
        firstName = this.firstName,
        lastName = this.lastName,
        personalPhone = this.personalPhone,
        roleName = this.role.name,
        isVerified = this.isVerified,
        selectedPlan = this.selectedPlan?.name,
        isOrganization = org != null,
        orgUuid = org?.orgUuid,
        orgName = org?.orgName,
        verificationStatus = org?.verificationStatus ?: "PENDING",
        isOnboardingComplete = this.isOnboardingComplete
    )
}